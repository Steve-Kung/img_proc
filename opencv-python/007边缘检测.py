'''
边缘检测
Canny边缘检测方法常被誉为边缘检测的最优方法

opencv函数：cv2.Canny(),
'''
# 导入相应的包
import cv2
import numpy as np

# 定义相应的常量

# 定义相应的函数

# main函数
# 读入图像并进行二值处理
img = cv2.imread('002.jpg', 0)
# 自动阈值分割cv2.THRESH_OTSU
# ret, thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
ret, thresh = cv2.threshold(img, 100, 255, cv2.THRESH_BINARY)
cv2.imshow('thresh', thresh)
kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))  # 矩形结构
dilation = cv2.dilate(thresh, kernel)  # 膨胀

# 参数2、3表示最低、高
# 阈值像素点的值大于最高阈值，那肯定是边缘
# 同理像素值小于最低阈值，那肯定不是边缘
# 像素值介于两者之间，如果与高于最高阈值的点连接，也算边缘
# Canny推荐的高低阈值比在2:1到3:1之间。
# 其实很多情况下，阈值分割后再检测边缘，效果会更好
edges = cv2.Canny(dilation, 30, 70)  # canny边缘检测
# np.hstack:按水平方向（列顺序）堆叠数组构成一个新的数组
# np.vstack:按垂直方向（行顺序）堆叠数组构成一个新的数组
cv2.imshow('edges', np.hstack((img, thresh, dilation, edges)))

cv2.waitKey(0)  # 不断刷新图像,返回值为当前键盘按键值，如果不按键一直等待,0表示无限等待
# 销毁所有窗口
cv2.destroyAllWindows()



'''
# ----------------------------------------------------------------------------------------------------------------

'''

'''
# ----------------------------------------------------------------------------------------------------------------

'''

'''
# ----------------------------------------------------------------------------------------------------------------

'''

'''
# ----------------------------------------------------------------------------------------------------------------

'''